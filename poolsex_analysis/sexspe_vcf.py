#!/usr/bin/python
import argparse
import pandas as pd
import sys
from datetime import date
import os


"""
This script is to generate a vcf file containing filtered sex specific SNPs for separating Y and X specific squeuences.
For filtering:
1. Only SNPs were kept and small indels were filter out
2. For each sex position, just two bases frequency between 0.3 to 0.7 in the heterogametic sex were kept, and variant that
   more than 2 base frequency > 0.1 were filtered out.
"""


def mem_usage(pandas_obj):
    if isinstance(pandas_obj, pd.DataFrame):
        usage_b = pandas_obj.memory_usage(deep=True).sum()
    else:  # we assume if not a df it's a series
        usage_b = pandas_obj.memory_usage(deep=True)
    usage_mb = usage_b / 1024 ** 2  # convert bytes to megabytes
    return "{:03.2f} MB".format(usage_mb)


def main():
    parser = argparse.ArgumentParser(
        description='Generating a sex specific SNPs variants file',
        usage='''python3 sexspe_vcf.py -s sync_file -n SNPs_position file [-o output file]'''
    )
    parser.add_argument('--sync-file', '-s',
                        help='Path to sync file generated by Poopolation2')
    parser.add_argument('--snp-file', '-n',
                        help='Path to snps_position file gene')
    parser.add_argument('--output-file', '-o', nargs='?', default='sex_spe_snps.vcf',
                        help='Path to output file')
    # parser.add_argument('--output-file', '-o',
    #                     help='Path to output file', nargs='?',
    #                     default='haplotypes_matrix.tsv')
    args = parser.parse_args(sys.argv[1:])
    if not args.sync_file or not os.path.isfile(args.sync_file):
        print('\nError: no valid sync file specified\n')
        parser.print_usage()
        print()
        exit(1)
    if not args.snp_file or not os.path.isfile(args.snp_file):
        print('\nError: no valid snps_position file specified\n')
        parser.print_usage()
        print()
        exit(1)

    vcf = pd.DataFrame(columns=["CHROM", "POS", "REF", "ALT", "QUAL", "FILTER", "INFO"])
    # sync = pd.read_csv(args.sync_file, delimiter='\t', header=None)
    snp = pd.read_csv(args.snp_file, sep='\t', header=None)
    # Input sync file sequentially
    # tricky to save memory when load big data (>1G).
    df_chunk = pd.read_csv(args.sync_file, chunksize=1000000, header=None, sep='\t')
    chunk_list = []  # append each chunk df here

    # Each chunk is in df format
    for chunk in df_chunk:
        # perform data filtering
        # chunk_filter = chunk_preprocessing(chunk)
        # Once the data filtering is done, append the chunk to list
        chunk.iloc[:, [0, 2, 3, 4]] = chunk.iloc[:, [0, 2, 3, 4]].astype('category')
        chunk.iloc[:, 1] = chunk.iloc[:, 1].astype('int32')
        chunk_list.append(chunk)
        # concat the list into dataframe
        sync = pd.concat(chunk_list)
    # print memory usage of sync data
    print("sync data used memory: {}".format(mem_usage(sync)))
    print(sync.dtypes)
    # check data information
    # snp.dtypes
    # snp.describe()
    # snp.info()
    # str(snp)
    # snp.ndim
    # snp.shape
    # sync.info(memory_usage='deep')

    # adding columns name, use rename function to rename, and drop function to delete columns
    # snp = snp.drop(columns="new")
    sync.columns = ["scaffold", "pos", "ref", "male", "female"]
    snp.columns = ["scaffold", "pos", "sex", "M_A", "M_T", "M_C", "M_G", "M_N", "M_I", "F_A", "F_T", "F_C", "F_G", "F_N", "F_I"]
    # Indels were not used in the vcf file
    snp = snp[((snp.M_I > 0.7) | (snp.M_I < 0.3)) & ((snp.F_I > 0.7) | (snp.F_I < 0.3))]
    snp = snp.reset_index(drop=True)
    FILTER = "pass"
    QUAL = "."
    for i in range(snp.shape[0]):
        CHROM = snp.at[i, "scaffold"]
        POS = snp.at[i, "pos"]
        REF = sync[sync["pos"] == POS]["ref"].reset_index(drop=True)[0]
        M_info = snp.iloc[i, 3:9]
        F_info = snp.iloc[i, 9:15]
        max_M = M_info.max()
        max_F = F_info.max()
    #     print(sync[sync["pos"] == POS]["female"].reset_index(drop=True)[0].split(":"))
    #     More than two variants (frequency > 0.1) in either sex were filtered out.
    #     Female specific SNPs
        if max_M > max_F and F_info[F_info > 0.1].count() < 3:
            SEX = "Female"
            share_allele = M_info.sort_values(ascending=False).index[0].split("_")[1]
            # depth
            dp = sync[sync["pos"] == POS]["female"].reset_index(drop=True)[0].split(":")
            DP = sum(list(map(int, dp)))
            # Major_Allele_fre = F_info.sort_values(ascending=False)[0]
            Major_Allele = F_info.sort_values(ascending=False).index[0].split("_")[1]
            # MAF(Minor_Allele_frequency)
            # MAF = F_info.sort_values(ascending=False)[1]
            Minor_Allele = F_info.sort_values(ascending=False).index[1].split("_")[1]
            het = [Major_Allele, Minor_Allele]
            if REF in het and share_allele in het:
                ALT = list(filter(lambda x: (x != REF), het))[0]
                # SA(sex specific allele)
                SA = list(filter(lambda x: (x != share_allele), het))[0]
            # elif REF != share_allele and share_allele in het and REF in het:
            #     ALT = ','.join(het)
            #     SA = list(filter(lambda x: (x != share_allele), het))[0]
            elif REF not in het and share_allele in het:
                ALT = ','.join(het)
                SA = list(filter(lambda x: (x != share_allele), het))[0]
            else:
                pass
        elif max_F > max_M and M_info[M_info > 0.1].count() < 3:
            SEX = "Male"
            share_allele = F_info.sort_values(ascending=False).index[0].split("_")[1]
            # depth
            dp = sync[sync["pos"] == POS]["male"].reset_index(drop=True)[0].split(":")
            DP = sum(list(map(int, dp)))
            # Major_Allele_fre = F_info.sort_values(ascending=False)[0]
            Major_Allele = M_info.sort_values(ascending=False).index[0].split("_")[1]
            # MAF(Minor_Allele_frequency)
            # MAF = M_info.sort_values(ascending=False)[1]
            Minor_Allele = M_info.sort_values(ascending=False).index[1].split("_")[1]
            het = [Major_Allele, Minor_Allele]
            if REF in het and share_allele in het:
                ALT = list(filter(lambda x: (x != REF), het))[0]
                # SA(sex specific allele)
                SA = list(filter(lambda x: (x != share_allele), het))[0]
            elif REF not in het and share_allele in het:
                ALT = ','.join(het)
                SA = list(filter(lambda x: (x != share_allele), het))[0]
            else:
                pass
        INFO = "DP={};SEX={};SA={}".format(DP, SEX, SA)
        vcf = vcf.append(pd.Series([CHROM, POS, REF, ALT, QUAL, FILTER, INFO], index=vcf.columns), ignore_index=True)
    # write file
    with open(args.output_file, 'w') as f:
        f.write('##fileformat=VCFv4.2' + "\n"
                "##fileDate={}".format(date.today()) + "\n"
                '##reference=Ameiurus_melas.after_review.fa' + "\n"
                '##FORMAT=<ID=DP,Number=1,Type=Integer,Description="Read Depth">' + "\n"
                '##INFO=<ID=SEX,Number=A,Type=Float,Description="Heterogametic Sex">' + "\n"
                '##INFO=<ID=SA,Number=1,Type=String,Description="Sex specific Allele">' + "\n"
                '#CHROM' + '\t' + 'POS' + '\t' + 'REF' + '\t' + 'ALT' + '\t' + 'QUAL' + '\t' + 'FILTER' + '\t' + 'INFO'  + "\n")
    vcf.to_csv(args.output_file, sep='\t', mode='a', header=False, index=False)
    print("A vcf file was generated with position_snps and sync file.")


if __name__ == '__main__':
    main()
